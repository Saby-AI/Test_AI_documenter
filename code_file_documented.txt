/**
 * Date: 11/09/2025
 * User: Agentic_AI_System_Documenter
 * Code Language: TypeScript
 */
async function processReceiving(
  loadOutLoadinQry: string,
  lnQcount: number,
  lnWcount: number,
  fscanentime: number
): Promise<void> {
  try {
    await this.manager()
      .query(`BEGIN ${loadOutLoadinQry}; END;`)
      .catch((error) => {
        this.logger.error(
          { lnQcount, lnWcount, fscanentime },
          'Error in LOADOUT/LOADIN UPDATE Query',
          'RECEIVING > PROCESS_OUTCLOSE'
        );
        throw error; // Re-throw the error to be handled in the outer catch
      });
  } catch (error) {
    // Log the error for OUTCLOSE processing
    this.logger.error(
      { error, message: 'LOADIN error OUTCLOSE -->' },
      'Error in OUTCLOSE',
      ReceivingService.name
    );
  }
  this.logger.debug(
    {
      service: ReceivingService.name,
      curOper: recvo.curOper,
    },
    `receiving --> OUTCLOSE | Elapsed time ${moment().diff(startTime)} ms | OUT Time ${moment().format('HH:mm:ss-SSS')}`
  );
}
async SEEIFXDOCK(recvo: ReceivingVO): Promise<void> {
  // Check for batch and LOADIN properties before proceeding
  if (
    recvo.lc_batch &&
    recvo.lc_batch.length > 0 &&
    recvo.LOADIN &&
    recvo.LOADIN?.fhasxdock !== true
  ) {
    const HASXDOCKresult = await this.manager().query(
      `BEGIN SELECT TOP 1 id FROM dbo.INV_MST WHERE fcanxdock = 1 and fproduct = '${recvo.lc_prod}' and fcustcode = '${recvo.lc_CustCode}' order by fbatch ASC ; END`
    );
    // Assign the result to a typed variable
    const HASXDOCK: InvMst = HASXDOCKresult[0];
    if (HASXDOCK) {
      const LOADINresult = await this.manager().query(
        `BEGIN
          SELECT TOP 1 id, fbatch, TRIM(fcustcode) as fcustcode, TRIM(fowner) as fowner, fsupplynum, fsupplynme, fbdate, floadnum, freference, fcarrier, fcheckqty, fcheckgros, fcomment, fccomment, fnotes, fltime, fshipstat, finuse, ftranmeth, fseal, ftrailer, fponum, favgtemp, ffronttemp, fmidtemp, fbacktemp, fdoornum, fbilldoc, fprinted, ftrancust, feditype, fpalexchng, fpalcond, floadoptcd, fdtecngrsn, fcarchgrsn, fversion, fpallets, fchep, fedi, fedisnddte, fedisndtme, foedi, foedisdte, foedistme, fscanstat, TRIM(fscanwho) as fscanwho, fscanstdte, fscanendte, fscanentme, farrivedte, farrivetme, fstartdte, fstarttme, ffinishdte, ffinishtme, fcolrcvd, fcolshort, fcoldamage, fcolover, fcolother, fcolcoment, ffrzrcvd, ffrzshort, ffrzdamage, ffrzover, ffrzother, ffrzcoment, fdryrcvd, fdryshort, fdrydamage, fdryover, fdryother, fdrycoment, fconfirmnm,
          flivedrop, fschcomment, fsignintme, fsignindte, fdriver, fwho, fdatestamp, ftimestamp, fwhorcvd, frcvddte, frcvdtme, fconfwhen, fconfwho, fchepcust, fgroupcode, fcpc, fconsignor, foutbatch, fhasxdock, fedi947, f9edisdte, f9edistme, forgsched, fcrtebymod, festnum, fo_arivdte, fcustdata, ftmphppzne, fediapt214, fapt214dtm, fplanned, ftmsscac, ftmsloadid, ftmsresend, cancelled
        FROM dbo.Loadin
        WHERE fbatch = '${recvo.lc_batch.padStart(7, '0')}'
        order by fbatch ASC ;
        END`
      );
      const LOADIN: Loadin = LOADINresult[0]; // The returned LOADIN record
      if (LOADIN) {
        LOADIN.fhasxdock = true; // Update the hasxdock flag
        await this.manager().query(
          `BEGIN UPDATE Loadin set fhasxdock = 1 WHERE fbatch = '${recvo.lc_batch.padStart(7, '0')}'; END`
        );
        recvo.LOADIN = LOADIN; // Assign updated Loadin record back to recvo
      }
    }
  }
}
async WRITEINVCONTROL(
  fwho: string,
  recvo: ReceivingVO,
  fproblem: string,
  fhowfixed: string,
  fresolved: boolean,
): Promise<void> {
  // Determine timestamp based on resolution status
  const fwhen: string = fresolved
    ? `CAST([dbo].[Localdatetime](sysdatetime()) AS datetime2)`
    : `Null`;
  await this.facilityService.getConnection().createEntityManager()
    .query(`BEGIN INSERT into INVCONTROL (
      foperid, fdatestamp, fworktype, fbatch, fpalletid, fproblem, fhowfixed, fcustcode, fwho, fwhen, fresolved
      ) VALUES (
        '${fwho}',
        CAST([dbo].[Localdatetime](sysdatetime()) AS datetime2),
        'RFDATECHEC',
        '${recvo.lc_batch}',
        '${recvo.lc_pal}',
        '${fproblem}',
        '${fhowfixed}',
        '${recvo.lc_CustCode}',
        '${fresolved ? fwho : ''}',
        ${fwhen},
        ${fresolved ? 1 : 0}
      ); END;`);
}
async validConsignee(tcConsignee: string): Promise<boolean> {
  let result: boolean = false;
  const CONSIGNEEres = await this.manager().query(
    `BEGIN SELECT TOP 1 TRIM(fcustcode) fcustcode from CONSIGNEE where fcustcode = '${tcConsignee}' order by fcustcode ASC ; END`
  );
  if (CONSIGNEEres.length > 0 && CONSIGNEEres[0]?.fcustcode.length > 0) {
    result = true; // Valid consignee found
  }
  return result; // return validation status
}
// Function declaration for adding/updating Cross Reference
async addUpdateConsCross(tcPal: string, tcConsignee: string): Promise<void> {
  await this.facilityService
    .getConnection()
    .createEntityManager()
    .transaction(async (transactionalEntityManager) => {
      await transactionalEntityManager.query(
        `MERGE CONSCROSS as Target
        USING (SELECT FTRACK, FSERIAL FROM PHY_MST WHERE FPALLETID=@0) as Source
        ON (Source.FTRACK=Target.FTRACK AND Source.FSERIAL=Target.FSERIAL)
        WHEN NOT MATCHED BY Target
        THEN INSERT (FTRACK, FSERIAL, FCONSCODE) VALUES (Source.FTRACK, Source.FSERIAL, @1)
        WHEN MATCHED THEN UPDATE SET Target.FCONSCODE = @1;`,
        [tcPal, tcConsignee]
      );
    });
}
// Function to convert YYWWD format to YYYYMMDD
YYWWDConverter(tcDate: string, tcDateType: string): string {
  let lcReturn: string = '';
  try {
    if (tcDate.length === 5 && (tcDateType === 'J' || tcDateType === 'C')) {
      const lcYy = tcDate.slice(0, 2);
      const lcWw = Number(tcDate.slice(2, 4));
      const lcD = Number(tcDate.slice(4, 5));
      if (lcWw > 0 && lcWw < 54 && lcD > 0 && lcD < 8) {
        let lastDay = moment();
        lastDay.set('year', Number(`20${lcYy}`));
        lastDay.set('month', 0);
        lastDay.set('date', 1);
        let day = (lcWw - 1) * 7 + (lcD - 2);
        day = day > 0 ? day : 0;
        day = day < 364 ? day : 364;
        lastDay = moment(lastDay).add(day, 'days');
        lcReturn = lastDay.format('YYYYMMDD');
        if (tcDateType === 'J') {
          lcReturn = this.RFDTOJ(lcReturn); // Convert to Julian format if required
        }
      }
    }
  } catch (error) {
    this.logger.error(
      { error, message: 'LOADIN error YYWWDConverter -->' },
      'Error in YYWWDConverter',
      ReceivingService.name
    );
  }
  return lcReturn; // Return converted date
}
// Function for retrieving Lot Pattern Configuration
async getLotPatternConfig(recVO: ReceivingVO, CODE2: Code2) {
  const recvo = recVO;
  recvo.lc_LotPattern = '';
  recvo.ln_LotPatternStart = 0;
  const CODELKUPresult = await this.manager().query(
    `BEGIN SELECT top 1 id, flist, flong, fshort, fcustcode, fcustlong FROM dbo.CODELKUP
     WHERE FLIST='CD' AND (FCUSTCODE='${CODE2.fcustcode}' OR ISNULL(FCUSTCODE,'')='')
     order by FLIST+FCUSTCODE+FSHORT ASC ; END;`
  );
  const CODELKUP: Codelkup = CODELKUPresult[0]; // Find the code look up record
  if (CODELKUP) {
    if (
      `CD${CODE2.fcustcode}${CODE2.flotpatid}` ===
      `${CODELKUP.flist}${CODELKUP.fcustcode}${CODELKUP.fshort}`
    ) {
      recvo.lc_LotPattern = CODELKUP.flong?.trim() || '';
      recvo.ln_LotPatternStart =
        Number.isNaN(CODELKUP.fcustlong) && Number(CODELKUP.fcustlong) > 0
          ? Number(CODELKUP.fcustlong)
          : 1;
    } else if (
      `CD${'          '}${CODE2.flotpatid}` ===
      `${CODELKUP.flist}${CODELKUP.fcustcode}${CODELKUP.fshort}`
    ) {
      recvo.lc_LotPattern = CODELKUP.flong?.trim() || '';
      recvo.ln_LotPatternStart =
        Number.isNaN(CODELKUP.fcustlong) && Number(CODELKUP.fcustlong) > 0
          ? Number(CODELKUP.fcustlong)
          : 1;
    }
  }
}
// Function that converts lot pattern date based on given parameters
LotPatternDateConverter(
  recvo: ReceivingVO,
  tcLotData: string,
  pcLotPattern: string,
  tnLotPatternStart: number,
  tcDateType: string
): string {
  let lcReturn = tcLotData; // Default return value is the original lot data
  const tcLotPattern = pcLotPattern.trim();
  try {
    // Count how many instances of Y, M, D, J and A are in the lot pattern
    const lnYCount: number = tcLotPattern.split('Y').length - 1;
    const lnMCount: number = tcLotPattern.split('M').length - 1;
    const lnDCount: number = tcLotPattern.split('D').length - 1;
    const lnJCount: number = tcLotPattern.split('J').length - 1;
    const lnACount: number = tcLotPattern.split('A').length - 1;
    // Check if the pattern is valid based on counts
    if (
      lnYCount + lnMCount + lnDCount + lnJCount + lnACount !==
      tcLotPattern.length
    ) {
      return lcReturn; // Return original if counts do not match
    }
    if (tcLotPattern.length === 0) {
      return lcReturn; // Return original if empty
    }
    if ([1, 2, 4].includes(lnYCount)) {
      return lcReturn; // Invalid patterns with 1, 2, or 4 Y's
    }
    if (
      lnJCount > 0 &&
      (lnMCount > 0 || lnDCount > 0 || lnJCount !== 3 || lnACount > 0)
    ) {
      return lcReturn; // Invalid pattern checks for J
    }
    if (
      lnDCount > 0 &&
      (lnDCount !== 2 ||
        lnJCount > 0 ||
        (lnMCount !== 2 && lnACount !== 3) ||
        (lnMCount === 2 && lnACount !== 0) ||
        (lnACount === 3 && lnMCount !== 0))
    ) {
      return lcReturn; // Invalid pattern checks for D
    }
    if (
      lnYCount !== tcLotPattern.split('Y').length - 1 &&
      (lnMCount === 0 || tcLotPattern.split('MM').length - 1 === 1) &&
      (lnDCount === 0 || tcLotPattern.split('DD').length - 1 === 1) &&
      (lnJCount === 0 || tcLotPattern.split('JJJ').length - 1 === 1) &&
      (lnACount === 0 || tcLotPattern.split('AAA').length - 1 === 1)
    ) {
      return lcReturn; // Pattern is invalid
    }
    // Convert to appropriate date format
    if (lnDCount === 2) {
      // Handle specific lot pattern date processing
    } else {
      lcReturn = recvo.lc_dtetyp === 'J' ? this.RFJTOD(lcReturn) : lcReturn; // Return formatted Julian date if required
    }
    this.logger.debug(
      'receiving-->',
      `LotPatternDateConverter --> ${tcLotPattern}, ${tnLotPatternStart}, ${tcDateType}`
    );
    return lcReturn; // Final return value
  } catch (error) {
    this.logger.error(
      { error, message: 'LotPatternDateConverter -->' },
      'Error in LotPatternDateConverter',
      ReceivingService.name
    );
  }
  return lcReturn; // Return original lot data on error
}
// Other remaining methods and codes follow...
// NOTE: Continued implementation follows similar patterns as illustrated with detailed function definitions and inline comments.